# WM 2.0 CLI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Go CLI tool that wraps `git worktree` with better UX - init, add, list, remove commands with file sync and background tasks.

**Architecture:** Cobra CLI framework with Bubble Tea TUI for interactive init. Internal packages for git operations, config parsing, file sync, and monorepo detection. Single binary distribution.

**Tech Stack:** Go 1.25, Cobra (CLI), Bubble Tea (TUI), Lip Gloss (styling), gopkg.in/yaml.v3 (config)

---

## Phase 1: Project Skeleton

### Task 1: Initialize Go Module

**Files:**
- Create: `go.mod`
- Create: `main.go`

**Step 1: Initialize Go module**

Run:
```bash
cd /Users/donghun/personal/wm && go mod init github.com/donghun/wm
```
Expected: `go.mod` created

**Step 2: Create minimal main.go**

```go
package main

import "fmt"

func main() {
	fmt.Println("wm - git worktree manager")
}
```

**Step 3: Verify it compiles**

Run: `go build -o wm .`
Expected: Binary `wm` created, runs without error

**Step 4: Commit**

```bash
git add go.mod main.go
git commit -m "chore: initialize go module"
```

---

### Task 2: Add Cobra CLI Framework

**Files:**
- Modify: `go.mod`
- Modify: `main.go`
- Create: `cmd/root.go`

**Step 1: Install Cobra dependency**

Run:
```bash
go get github.com/spf13/cobra@latest
```
Expected: `go.mod` updated with cobra dependency

**Step 2: Create root command**

Create `cmd/root.go`:
```go
package cmd

import (
	"os"

	"github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
	Use:   "wm",
	Short: "Git worktree manager",
	Long:  "WM is a CLI tool that makes git worktree easier to use with file sync and background tasks.",
}

func Execute() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}
```

**Step 3: Update main.go to use Cobra**

```go
package main

import "github.com/donghun/wm/cmd"

func main() {
	cmd.Execute()
}
```

**Step 4: Verify CLI works**

Run: `go run . --help`
Expected: Help text displayed with "Git worktree manager"

**Step 5: Commit**

```bash
git add go.mod go.sum main.go cmd/
git commit -m "feat: add cobra CLI framework"
```

---

### Task 3: Add Version Command

**Files:**
- Create: `cmd/version.go`
- Create: `internal/version/version.go`

**Step 1: Create version package**

Create `internal/version/version.go`:
```go
package version

var (
	Version   = "dev"
	GitCommit = "unknown"
	BuildDate = "unknown"
)

func String() string {
	return Version + " (" + GitCommit + ") built " + BuildDate
}
```

**Step 2: Create version command**

Create `cmd/version.go`:
```go
package cmd

import (
	"fmt"

	"github.com/donghun/wm/internal/version"
	"github.com/spf13/cobra"
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print version information",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("wm", version.String())
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
}
```

**Step 3: Verify version command**

Run: `go run . version`
Expected: Output like "wm dev (unknown) built unknown"

**Step 4: Commit**

```bash
git add cmd/version.go internal/
git commit -m "feat: add version command"
```

---

## Phase 2: Configuration

### Task 4: Create Config Schema Types

**Files:**
- Create: `internal/config/types.go`

**Step 1: Write the test**

Create `internal/config/types_test.go`:
```go
package config

import "testing"

func TestConfigDefaults(t *testing.T) {
	cfg := NewConfig()
	if cfg.Version != 1 {
		t.Errorf("expected version 1, got %d", cfg.Version)
	}
	if cfg.Worktree.BaseDir != "../wm_{repo}" {
		t.Errorf("expected default base_dir, got %s", cfg.Worktree.BaseDir)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/config/... -v`
Expected: FAIL - package not found or NewConfig not defined

**Step 3: Implement config types**

Create `internal/config/types.go`:
```go
package config

// Config represents the .wm.yaml file structure
type Config struct {
	Version  int             `yaml:"version"`
	Worktree WorktreeConfig  `yaml:"worktree"`
	Scan     ScanConfig      `yaml:"scan"`
	Sync     []SyncItem      `yaml:"sync"`
	Tasks    TasksConfig     `yaml:"tasks"`
}

type WorktreeConfig struct {
	BaseDir string `yaml:"base_dir"`
}

type ScanConfig struct {
	IgnoreDirs []string `yaml:"ignore_dirs"`
}

// SyncItem can be a string path or an object with src/dst/mode/when
type SyncItem struct {
	Src  string `yaml:"src"`
	Dst  string `yaml:"dst,omitempty"`
	Mode string `yaml:"mode,omitempty"` // "copy" (default) or "symlink"
	When string `yaml:"when,omitempty"` // "always" (default) or "missing"
}

type TasksConfig struct {
	PostInstall PostInstallConfig `yaml:"post_install"`
}

type PostInstallConfig struct {
	Mode     string   `yaml:"mode"`
	Commands []string `yaml:"commands"`
	Notify   string   `yaml:"notify,omitempty"`
}

// NewConfig returns a Config with default values
func NewConfig() *Config {
	return &Config{
		Version: 1,
		Worktree: WorktreeConfig{
			BaseDir: "../wm_{repo}",
		},
		Scan: ScanConfig{
			IgnoreDirs: []string{".git", "node_modules", "dist", "build", ".next", "target", "vendor"},
		},
		Sync:  []SyncItem{},
		Tasks: TasksConfig{},
	}
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/config/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/config/
git commit -m "feat: add config types with defaults"
```

---

### Task 5: Implement Config Loader

**Files:**
- Create: `internal/config/loader.go`
- Create: `internal/config/loader_test.go`

**Step 1: Write the test**

Create `internal/config/loader_test.go`:
```go
package config

import (
	"os"
	"path/filepath"
	"testing"
)

func TestLoadConfig(t *testing.T) {
	// Create temp directory
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, ".wm.yaml")

	// Write test config
	content := []byte(`version: 1
worktree:
  base_dir: "../custom_wm"
sync:
  - ".env"
  - src: ".env.example"
    dst: ".env"
    mode: copy
    when: missing
tasks:
  post_install:
    mode: background
    commands:
      - "pnpm install"
`)
	if err := os.WriteFile(configPath, content, 0644); err != nil {
		t.Fatal(err)
	}

	cfg, err := LoadConfig(configPath)
	if err != nil {
		t.Fatalf("LoadConfig failed: %v", err)
	}

	if cfg.Worktree.BaseDir != "../custom_wm" {
		t.Errorf("expected base_dir '../custom_wm', got %s", cfg.Worktree.BaseDir)
	}

	if len(cfg.Sync) != 2 {
		t.Errorf("expected 2 sync items, got %d", len(cfg.Sync))
	}

	if cfg.Sync[0].Src != ".env" {
		t.Errorf("expected first sync item '.env', got %s", cfg.Sync[0].Src)
	}

	if cfg.Sync[1].Mode != "copy" {
		t.Errorf("expected mode 'copy', got %s", cfg.Sync[1].Mode)
	}
}

func TestLoadConfigNotFound(t *testing.T) {
	_, err := LoadConfig("/nonexistent/.wm.yaml")
	if err == nil {
		t.Error("expected error for nonexistent config")
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/config/... -v -run TestLoadConfig`
Expected: FAIL - LoadConfig not defined

**Step 3: Install yaml dependency**

Run:
```bash
go get gopkg.in/yaml.v3
```

**Step 4: Implement loader**

Create `internal/config/loader.go`:
```go
package config

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

const ConfigFileName = ".wm.yaml"

// LoadConfig reads and parses a .wm.yaml file
func LoadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config: %w", err)
	}

	cfg := NewConfig()
	if err := yaml.Unmarshal(data, cfg); err != nil {
		return nil, fmt.Errorf("failed to parse config: %w", err)
	}

	// Handle string-only sync items (yaml unmarshal doesn't handle union types)
	if err := cfg.normalizeSyncItems(data); err != nil {
		return nil, err
	}

	return cfg, nil
}

// normalizeSyncItems handles the mixed string/object format in sync
func (c *Config) normalizeSyncItems(data []byte) error {
	// Re-parse just the sync section to handle mixed types
	var raw struct {
		Sync []yaml.Node `yaml:"sync"`
	}
	if err := yaml.Unmarshal(data, &raw); err != nil {
		return err
	}

	c.Sync = make([]SyncItem, len(raw.Sync))
	for i, node := range raw.Sync {
		if node.Kind == yaml.ScalarNode {
			// String value - just a path
			c.Sync[i] = SyncItem{
				Src:  node.Value,
				Mode: "copy",
				When: "always",
			}
		} else if node.Kind == yaml.MappingNode {
			// Object value
			var item SyncItem
			if err := node.Decode(&item); err != nil {
				return fmt.Errorf("failed to parse sync item %d: %w", i, err)
			}
			// Set defaults
			if item.Mode == "" {
				item.Mode = "copy"
			}
			if item.When == "" {
				item.When = "always"
			}
			if item.Dst == "" {
				item.Dst = item.Src
			}
			c.Sync[i] = item
		}
	}

	return nil
}

// FindConfig searches for .wm.yaml starting from dir and walking up
func FindConfig(dir string) (string, error) {
	for {
		path := dir + "/" + ConfigFileName
		if _, err := os.Stat(path); err == nil {
			return path, nil
		}

		parent := dir[:max(0, len(dir)-len(filepath.Base(dir))-1)]
		if parent == dir || parent == "" {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("no %s found", ConfigFileName)
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

**Step 5: Fix import in loader.go**

Add missing import:
```go
import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)
```

**Step 6: Run test to verify it passes**

Run: `go test ./internal/config/... -v`
Expected: PASS

**Step 7: Commit**

```bash
git add internal/config/ go.mod go.sum
git commit -m "feat: add config loader with mixed sync format support"
```

---

### Task 6: Add Config Save Function

**Files:**
- Modify: `internal/config/loader.go`
- Modify: `internal/config/loader_test.go`

**Step 1: Write the test**

Add to `internal/config/loader_test.go`:
```go
func TestSaveConfig(t *testing.T) {
	tmpDir := t.TempDir()
	configPath := filepath.Join(tmpDir, ".wm.yaml")

	cfg := NewConfig()
	cfg.Worktree.BaseDir = "../test_wm"
	cfg.Sync = []SyncItem{
		{Src: ".env", Mode: "copy", When: "always"},
	}

	if err := SaveConfig(configPath, cfg); err != nil {
		t.Fatalf("SaveConfig failed: %v", err)
	}

	// Verify by loading
	loaded, err := LoadConfig(configPath)
	if err != nil {
		t.Fatalf("LoadConfig failed: %v", err)
	}

	if loaded.Worktree.BaseDir != "../test_wm" {
		t.Errorf("expected base_dir '../test_wm', got %s", loaded.Worktree.BaseDir)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/config/... -v -run TestSaveConfig`
Expected: FAIL - SaveConfig not defined

**Step 3: Implement SaveConfig**

Add to `internal/config/loader.go`:
```go
// SaveConfig writes a Config to a .wm.yaml file
func SaveConfig(path string, cfg *Config) error {
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	return nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/config/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/config/
git commit -m "feat: add config save function"
```

---

## Phase 3: Git Operations

### Task 7: Create Git Worktree Wrapper

**Files:**
- Create: `internal/git/worktree.go`
- Create: `internal/git/worktree_test.go`

**Step 1: Write the test**

Create `internal/git/worktree_test.go`:
```go
package git

import (
	"os"
	"os/exec"
	"path/filepath"
	"testing"
)

func setupTestRepo(t *testing.T) string {
	t.Helper()
	tmpDir := t.TempDir()

	// Initialize a git repo with initial commit
	cmds := [][]string{
		{"git", "init"},
		{"git", "config", "user.email", "test@test.com"},
		{"git", "config", "user.name", "Test"},
		{"touch", "README.md"},
		{"git", "add", "."},
		{"git", "commit", "-m", "initial"},
	}

	for _, args := range cmds {
		cmd := exec.Command(args[0], args[1:]...)
		cmd.Dir = tmpDir
		if out, err := cmd.CombinedOutput(); err != nil {
			t.Fatalf("setup command %v failed: %v\n%s", args, err, out)
		}
	}

	return tmpDir
}

func TestListWorktrees(t *testing.T) {
	repoDir := setupTestRepo(t)

	wts, err := ListWorktrees(repoDir)
	if err != nil {
		t.Fatalf("ListWorktrees failed: %v", err)
	}

	if len(wts) != 1 {
		t.Errorf("expected 1 worktree (main), got %d", len(wts))
	}

	if wts[0].Path != repoDir {
		t.Errorf("expected path %s, got %s", repoDir, wts[0].Path)
	}
}

func TestAddWorktree(t *testing.T) {
	repoDir := setupTestRepo(t)
	wtPath := filepath.Join(t.TempDir(), "feature-branch")

	err := AddWorktree(repoDir, wtPath, "feature-branch", true)
	if err != nil {
		t.Fatalf("AddWorktree failed: %v", err)
	}

	// Verify worktree exists
	if _, err := os.Stat(wtPath); os.IsNotExist(err) {
		t.Error("worktree directory was not created")
	}

	// Verify it shows in list
	wts, _ := ListWorktrees(repoDir)
	if len(wts) != 2 {
		t.Errorf("expected 2 worktrees, got %d", len(wts))
	}
}

func TestRemoveWorktree(t *testing.T) {
	repoDir := setupTestRepo(t)
	wtPath := filepath.Join(t.TempDir(), "to-remove")

	// Add worktree first
	if err := AddWorktree(repoDir, wtPath, "to-remove", true); err != nil {
		t.Fatalf("AddWorktree failed: %v", err)
	}

	// Remove it
	if err := RemoveWorktree(repoDir, wtPath, false); err != nil {
		t.Fatalf("RemoveWorktree failed: %v", err)
	}

	// Verify it's gone from list
	wts, _ := ListWorktrees(repoDir)
	if len(wts) != 1 {
		t.Errorf("expected 1 worktree after removal, got %d", len(wts))
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/git/... -v`
Expected: FAIL - package not found

**Step 3: Implement git worktree wrapper**

Create `internal/git/worktree.go`:
```go
package git

import (
	"bufio"
	"bytes"
	"fmt"
	"os/exec"
	"strings"
)

// Worktree represents a git worktree entry
type Worktree struct {
	Path   string
	HEAD   string
	Branch string
	Bare   bool
}

// ListWorktrees returns all worktrees for a repository
func ListWorktrees(repoDir string) ([]Worktree, error) {
	cmd := exec.Command("git", "worktree", "list", "--porcelain")
	cmd.Dir = repoDir

	out, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("git worktree list failed: %w", err)
	}

	return parseWorktreeList(out), nil
}

func parseWorktreeList(data []byte) []Worktree {
	var worktrees []Worktree
	var current Worktree

	scanner := bufio.NewScanner(bytes.NewReader(data))
	for scanner.Scan() {
		line := scanner.Text()

		if line == "" {
			if current.Path != "" {
				worktrees = append(worktrees, current)
				current = Worktree{}
			}
			continue
		}

		switch {
		case strings.HasPrefix(line, "worktree "):
			current.Path = strings.TrimPrefix(line, "worktree ")
		case strings.HasPrefix(line, "HEAD "):
			current.HEAD = strings.TrimPrefix(line, "HEAD ")
		case strings.HasPrefix(line, "branch "):
			branch := strings.TrimPrefix(line, "branch ")
			// Remove refs/heads/ prefix
			current.Branch = strings.TrimPrefix(branch, "refs/heads/")
		case line == "bare":
			current.Bare = true
		}
	}

	// Don't forget the last entry
	if current.Path != "" {
		worktrees = append(worktrees, current)
	}

	return worktrees
}

// AddWorktree creates a new worktree
func AddWorktree(repoDir, path, branch string, createBranch bool) error {
	args := []string{"worktree", "add"}
	if createBranch {
		args = append(args, "-b", branch)
	}
	args = append(args, path)
	if !createBranch {
		args = append(args, branch)
	}

	cmd := exec.Command("git", args...)
	cmd.Dir = repoDir

	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("git worktree add failed: %w\n%s", err, out)
	}

	return nil
}

// RemoveWorktree removes a worktree
func RemoveWorktree(repoDir, path string, force bool) error {
	args := []string{"worktree", "remove"}
	if force {
		args = append(args, "--force")
	}
	args = append(args, path)

	cmd := exec.Command("git", args...)
	cmd.Dir = repoDir

	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("git worktree remove failed: %w\n%s", err, out)
	}

	return nil
}

// BranchExists checks if a branch exists
func BranchExists(repoDir, branch string) bool {
	cmd := exec.Command("git", "show-ref", "--verify", "--quiet", "refs/heads/"+branch)
	cmd.Dir = repoDir
	return cmd.Run() == nil
}

// DeleteBranch deletes a local branch
func DeleteBranch(repoDir, branch string, force bool) error {
	flag := "-d"
	if force {
		flag = "-D"
	}

	cmd := exec.Command("git", "branch", flag, branch)
	cmd.Dir = repoDir

	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("git branch delete failed: %w\n%s", err, out)
	}

	return nil
}

// GetRepoRoot returns the root directory of the git repository
func GetRepoRoot(dir string) (string, error) {
	cmd := exec.Command("git", "rev-parse", "--show-toplevel")
	cmd.Dir = dir

	out, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("not a git repository: %w", err)
	}

	return strings.TrimSpace(string(out)), nil
}

// GetCurrentBranch returns the current branch name
func GetCurrentBranch(dir string) (string, error) {
	cmd := exec.Command("git", "branch", "--show-current")
	cmd.Dir = dir

	out, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get current branch: %w", err)
	}

	return strings.TrimSpace(string(out)), nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/git/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/git/
git commit -m "feat: add git worktree wrapper"
```

---

## Phase 4: File Sync

### Task 8: Implement File Sync

**Files:**
- Create: `internal/sync/sync.go`
- Create: `internal/sync/sync_test.go`

**Step 1: Write the test**

Create `internal/sync/sync_test.go`:
```go
package sync

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/donghun/wm/internal/config"
)

func TestSyncCopy(t *testing.T) {
	srcDir := t.TempDir()
	dstDir := t.TempDir()

	// Create source file
	srcFile := filepath.Join(srcDir, ".env")
	if err := os.WriteFile(srcFile, []byte("SECRET=123"), 0644); err != nil {
		t.Fatal(err)
	}

	item := config.SyncItem{
		Src:  ".env",
		Dst:  ".env",
		Mode: "copy",
		When: "always",
	}

	if err := SyncFile(srcDir, dstDir, item); err != nil {
		t.Fatalf("SyncFile failed: %v", err)
	}

	// Verify copy
	dstFile := filepath.Join(dstDir, ".env")
	content, err := os.ReadFile(dstFile)
	if err != nil {
		t.Fatalf("failed to read dest file: %v", err)
	}

	if string(content) != "SECRET=123" {
		t.Errorf("expected 'SECRET=123', got '%s'", content)
	}
}

func TestSyncSymlink(t *testing.T) {
	srcDir := t.TempDir()
	dstDir := t.TempDir()

	// Create source file
	srcFile := filepath.Join(srcDir, ".env")
	if err := os.WriteFile(srcFile, []byte("SECRET=456"), 0644); err != nil {
		t.Fatal(err)
	}

	item := config.SyncItem{
		Src:  ".env",
		Dst:  ".env",
		Mode: "symlink",
		When: "always",
	}

	if err := SyncFile(srcDir, dstDir, item); err != nil {
		t.Fatalf("SyncFile failed: %v", err)
	}

	// Verify symlink
	dstFile := filepath.Join(dstDir, ".env")
	info, err := os.Lstat(dstFile)
	if err != nil {
		t.Fatalf("failed to stat dest file: %v", err)
	}

	if info.Mode()&os.ModeSymlink == 0 {
		t.Error("expected symlink, got regular file")
	}
}

func TestSyncWhenMissing(t *testing.T) {
	srcDir := t.TempDir()
	dstDir := t.TempDir()

	// Create source and existing dest
	srcFile := filepath.Join(srcDir, ".env.example")
	dstFile := filepath.Join(dstDir, ".env")
	if err := os.WriteFile(srcFile, []byte("NEW"), 0644); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(dstFile, []byte("EXISTING"), 0644); err != nil {
		t.Fatal(err)
	}

	item := config.SyncItem{
		Src:  ".env.example",
		Dst:  ".env",
		Mode: "copy",
		When: "missing",
	}

	if err := SyncFile(srcDir, dstDir, item); err != nil {
		t.Fatalf("SyncFile failed: %v", err)
	}

	// Should not overwrite
	content, _ := os.ReadFile(dstFile)
	if string(content) != "EXISTING" {
		t.Errorf("file was overwritten, expected 'EXISTING', got '%s'", content)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/sync/... -v`
Expected: FAIL - package not found

**Step 3: Implement sync**

Create `internal/sync/sync.go`:
```go
package sync

import (
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/donghun/wm/internal/config"
)

// SyncFile syncs a single file from srcDir to dstDir based on SyncItem config
func SyncFile(srcDir, dstDir string, item config.SyncItem) error {
	srcPath := filepath.Join(srcDir, item.Src)
	dstPath := filepath.Join(dstDir, item.Dst)

	// Check if source exists
	if _, err := os.Stat(srcPath); os.IsNotExist(err) {
		return nil // Skip if source doesn't exist
	}

	// Check "when" condition
	if item.When == "missing" {
		if _, err := os.Stat(dstPath); err == nil {
			return nil // Skip if dest already exists
		}
	}

	// Ensure destination directory exists
	dstDir = filepath.Dir(dstPath)
	if err := os.MkdirAll(dstDir, 0755); err != nil {
		return fmt.Errorf("failed to create dest directory: %w", err)
	}

	// Remove existing destination if it exists
	os.Remove(dstPath)

	switch item.Mode {
	case "symlink":
		return createSymlink(srcPath, dstPath)
	default: // "copy"
		return copyFile(srcPath, dstPath)
	}
}

func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return fmt.Errorf("failed to open source: %w", err)
	}
	defer srcFile.Close()

	srcInfo, err := srcFile.Stat()
	if err != nil {
		return fmt.Errorf("failed to stat source: %w", err)
	}

	dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, srcInfo.Mode())
	if err != nil {
		return fmt.Errorf("failed to create dest: %w", err)
	}
	defer dstFile.Close()

	if _, err := io.Copy(dstFile, srcFile); err != nil {
		return fmt.Errorf("failed to copy: %w", err)
	}

	return nil
}

func createSymlink(src, dst string) error {
	// Use absolute path for symlink target
	absSrc, err := filepath.Abs(src)
	if err != nil {
		return fmt.Errorf("failed to get absolute path: %w", err)
	}

	if err := os.Symlink(absSrc, dst); err != nil {
		return fmt.Errorf("failed to create symlink: %w", err)
	}

	return nil
}

// SyncAll syncs all files from config
func SyncAll(srcDir, dstDir string, items []config.SyncItem) error {
	for _, item := range items {
		// Handle glob patterns
		matches, err := filepath.Glob(filepath.Join(srcDir, item.Src))
		if err != nil {
			return fmt.Errorf("invalid glob pattern %s: %w", item.Src, err)
		}

		if len(matches) == 0 {
			// No glob match, try as literal path
			if err := SyncFile(srcDir, dstDir, item); err != nil {
				return err
			}
			continue
		}

		// Process each glob match
		for _, match := range matches {
			relPath, _ := filepath.Rel(srcDir, match)
			itemCopy := item
			itemCopy.Src = relPath
			if item.Dst == item.Src || item.Dst == "" {
				itemCopy.Dst = relPath
			}
			if err := SyncFile(srcDir, dstDir, itemCopy); err != nil {
				return err
			}
		}
	}

	return nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/sync/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/sync/
git commit -m "feat: add file sync with copy/symlink support"
```

---

## Phase 5: Monorepo Detection

### Task 9: Implement Monorepo Detection

**Files:**
- Create: `internal/detect/detect.go`
- Create: `internal/detect/detect_test.go`

**Step 1: Write the test**

Create `internal/detect/detect_test.go`:
```go
package detect

import (
	"os"
	"path/filepath"
	"testing"
)

func TestDetectPnpm(t *testing.T) {
	tmpDir := t.TempDir()

	// Create pnpm-workspace.yaml
	if err := os.WriteFile(filepath.Join(tmpDir, "pnpm-workspace.yaml"), []byte("packages:\n  - 'apps/*'"), 0644); err != nil {
		t.Fatal(err)
	}

	result := Detect(tmpDir)

	if result.PackageManager != "pnpm" {
		t.Errorf("expected pnpm, got %s", result.PackageManager)
	}

	if result.InstallCommand != "pnpm install" {
		t.Errorf("expected 'pnpm install', got %s", result.InstallCommand)
	}
}

func TestDetectNpm(t *testing.T) {
	tmpDir := t.TempDir()

	// Create package.json with workspaces
	content := `{"workspaces": ["packages/*"]}`
	if err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	result := Detect(tmpDir)

	if result.PackageManager != "npm" {
		t.Errorf("expected npm, got %s", result.PackageManager)
	}
}

func TestDetectYarn(t *testing.T) {
	tmpDir := t.TempDir()

	// Create yarn.lock
	if err := os.WriteFile(filepath.Join(tmpDir, "yarn.lock"), []byte(""), 0644); err != nil {
		t.Fatal(err)
	}
	// Create package.json
	if err := os.WriteFile(filepath.Join(tmpDir, "package.json"), []byte("{}"), 0644); err != nil {
		t.Fatal(err)
	}

	result := Detect(tmpDir)

	if result.PackageManager != "yarn" {
		t.Errorf("expected yarn, got %s", result.PackageManager)
	}
}

func TestDetectCargo(t *testing.T) {
	tmpDir := t.TempDir()

	// Create Cargo.toml with workspace
	content := `[workspace]
members = ["crates/*"]`
	if err := os.WriteFile(filepath.Join(tmpDir, "Cargo.toml"), []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	result := Detect(tmpDir)

	if result.PackageManager != "cargo" {
		t.Errorf("expected cargo, got %s", result.PackageManager)
	}

	if result.InstallCommand != "cargo build" {
		t.Errorf("expected 'cargo build', got %s", result.InstallCommand)
	}
}

func TestDetectGo(t *testing.T) {
	tmpDir := t.TempDir()

	// Create go.work
	if err := os.WriteFile(filepath.Join(tmpDir, "go.work"), []byte("go 1.21\nuse ./cmd"), 0644); err != nil {
		t.Fatal(err)
	}

	result := Detect(tmpDir)

	if result.PackageManager != "go" {
		t.Errorf("expected go, got %s", result.PackageManager)
	}

	if result.InstallCommand != "go mod download" {
		t.Errorf("expected 'go mod download', got %s", result.InstallCommand)
	}
}

func TestDetectNone(t *testing.T) {
	tmpDir := t.TempDir()

	result := Detect(tmpDir)

	if result.PackageManager != "" {
		t.Errorf("expected empty, got %s", result.PackageManager)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/detect/... -v`
Expected: FAIL - package not found

**Step 3: Implement detection**

Create `internal/detect/detect.go`:
```go
package detect

import (
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
)

// DetectionResult contains detected package manager info
type DetectionResult struct {
	PackageManager string
	InstallCommand string
	IsMonorepo     bool
}

// Detect analyzes a directory and returns package manager info
func Detect(dir string) DetectionResult {
	// Check pnpm first (pnpm-workspace.yaml)
	if fileExists(filepath.Join(dir, "pnpm-workspace.yaml")) {
		return DetectionResult{
			PackageManager: "pnpm",
			InstallCommand: "pnpm install",
			IsMonorepo:     true,
		}
	}

	// Check for pnpm-lock.yaml
	if fileExists(filepath.Join(dir, "pnpm-lock.yaml")) {
		return DetectionResult{
			PackageManager: "pnpm",
			InstallCommand: "pnpm install",
			IsMonorepo:     false,
		}
	}

	// Check yarn (yarn.lock)
	if fileExists(filepath.Join(dir, "yarn.lock")) {
		isMonorepo := hasWorkspacesInPackageJson(dir)
		return DetectionResult{
			PackageManager: "yarn",
			InstallCommand: "yarn install",
			IsMonorepo:     isMonorepo,
		}
	}

	// Check npm (package-lock.json or package.json with workspaces)
	if fileExists(filepath.Join(dir, "package-lock.json")) || fileExists(filepath.Join(dir, "package.json")) {
		isMonorepo := hasWorkspacesInPackageJson(dir)
		pm := "npm"
		if isMonorepo && !fileExists(filepath.Join(dir, "package-lock.json")) {
			// Has workspaces but no lock file - could be npm
		}
		return DetectionResult{
			PackageManager: pm,
			InstallCommand: "npm install",
			IsMonorepo:     isMonorepo,
		}
	}

	// Check Cargo (Cargo.toml with workspace)
	if fileExists(filepath.Join(dir, "Cargo.toml")) {
		isMonorepo := isCargoWorkspace(dir)
		return DetectionResult{
			PackageManager: "cargo",
			InstallCommand: "cargo build",
			IsMonorepo:     isMonorepo,
		}
	}

	// Check Go (go.work for workspace)
	if fileExists(filepath.Join(dir, "go.work")) {
		return DetectionResult{
			PackageManager: "go",
			InstallCommand: "go mod download",
			IsMonorepo:     true,
		}
	}

	// Check Go (go.mod for single module)
	if fileExists(filepath.Join(dir, "go.mod")) {
		return DetectionResult{
			PackageManager: "go",
			InstallCommand: "go mod download",
			IsMonorepo:     false,
		}
	}

	return DetectionResult{}
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func hasWorkspacesInPackageJson(dir string) bool {
	data, err := os.ReadFile(filepath.Join(dir, "package.json"))
	if err != nil {
		return false
	}

	var pkg struct {
		Workspaces interface{} `json:"workspaces"`
	}

	if err := json.Unmarshal(data, &pkg); err != nil {
		return false
	}

	return pkg.Workspaces != nil
}

func isCargoWorkspace(dir string) bool {
	data, err := os.ReadFile(filepath.Join(dir, "Cargo.toml"))
	if err != nil {
		return false
	}

	return strings.Contains(string(data), "[workspace]")
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/detect/... -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/detect/
git commit -m "feat: add monorepo detection for pnpm/npm/yarn/cargo/go"
```

---

## Phase 6: CLI Commands

### Task 10: Implement `wm list` Command

**Files:**
- Create: `cmd/list.go`

**Step 1: Create list command**

Create `cmd/list.go`:
```go
package cmd

import (
	"fmt"
	"os"
	"text/tabwriter"

	"github.com/donghun/wm/internal/git"
	"github.com/spf13/cobra"
)

var listCmd = &cobra.Command{
	Use:     "list",
	Aliases: []string{"ls"},
	Short:   "List all worktrees",
	Long:    "List all git worktrees in the current repository with their branches and status.",
	RunE:    runList,
}

func init() {
	rootCmd.AddCommand(listCmd)
}

func runList(cmd *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	repoRoot, err := git.GetRepoRoot(cwd)
	if err != nil {
		return err
	}

	worktrees, err := git.ListWorktrees(repoRoot)
	if err != nil {
		return err
	}

	if len(worktrees) == 0 {
		fmt.Println("No worktrees found.")
		return nil
	}

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
	fmt.Fprintln(w, "PATH\tBRANCH\tHEAD")
	fmt.Fprintln(w, "----\t------\t----")

	for _, wt := range worktrees {
		branch := wt.Branch
		if branch == "" {
			branch = "(detached)"
		}
		shortHead := wt.HEAD
		if len(shortHead) > 7 {
			shortHead = shortHead[:7]
		}
		fmt.Fprintf(w, "%s\t%s\t%s\n", wt.Path, branch, shortHead)
	}

	w.Flush()
	return nil
}
```

**Step 2: Verify list command**

Run: `go run . list`
Expected: Table showing worktrees (at least the main one)

**Step 3: Commit**

```bash
git add cmd/list.go
git commit -m "feat: add wm list command"
```

---

### Task 11: Implement `wm add` Command

**Files:**
- Create: `cmd/add.go`
- Create: `internal/runner/runner.go`

**Step 1: Create runner for background tasks**

Create `internal/runner/runner.go`:
```go
package runner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// RunCommands executes a list of commands in the specified directory
func RunCommands(dir string, commands []string, background bool) error {
	for _, cmdStr := range commands {
		parts := strings.Fields(cmdStr)
		if len(parts) == 0 {
			continue
		}

		cmd := exec.Command(parts[0], parts[1:]...)
		cmd.Dir = dir

		if background {
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			if err := cmd.Start(); err != nil {
				return fmt.Errorf("failed to start command '%s': %w", cmdStr, err)
			}
			// Wait for completion in goroutine, print errors
			go func(c *exec.Cmd, cmdStr string) {
				if err := c.Wait(); err != nil {
					fmt.Fprintf(os.Stderr, "Error: command '%s' failed: %v\n", cmdStr, err)
				}
			}(cmd, cmdStr)
		} else {
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			if err := cmd.Run(); err != nil {
				return fmt.Errorf("command '%s' failed: %w", cmdStr, err)
			}
		}
	}

	return nil
}
```

**Step 2: Create add command**

Create `cmd/add.go`:
```go
package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/donghun/wm/internal/config"
	"github.com/donghun/wm/internal/git"
	"github.com/donghun/wm/internal/runner"
	"github.com/donghun/wm/internal/sync"
	"github.com/spf13/cobra"
)

var addPath string

var addCmd = &cobra.Command{
	Use:   "add <branch>",
	Short: "Create a new worktree",
	Long:  "Create a new git worktree with file sync and optional background tasks.",
	Args:  cobra.ExactArgs(1),
	RunE:  runAdd,
}

func init() {
	addCmd.Flags().StringVarP(&addPath, "path", "p", "", "Custom path for the worktree")
	rootCmd.AddCommand(addCmd)
}

func runAdd(cmd *cobra.Command, args []string) error {
	branch := args[0]

	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	repoRoot, err := git.GetRepoRoot(cwd)
	if err != nil {
		return err
	}

	repoName := filepath.Base(repoRoot)

	// Load config if exists
	var cfg *config.Config
	configPath := filepath.Join(repoRoot, config.ConfigFileName)
	if _, err := os.Stat(configPath); err == nil {
		cfg, err = config.LoadConfig(configPath)
		if err != nil {
			return fmt.Errorf("failed to load config: %w", err)
		}
	} else {
		cfg = config.NewConfig()
	}

	// Determine worktree path
	var wtPath string
	if addPath != "" {
		wtPath = addPath
		if !filepath.IsAbs(wtPath) {
			wtPath = filepath.Join(cwd, wtPath)
		}
	} else {
		baseDir := cfg.Worktree.BaseDir
		baseDir = strings.ReplaceAll(baseDir, "{repo}", repoName)
		if !filepath.IsAbs(baseDir) {
			baseDir = filepath.Join(repoRoot, baseDir)
		}
		wtPath = filepath.Join(baseDir, branch)
	}

	// Check if branch exists
	branchExists := git.BranchExists(repoRoot, branch)

	if !branchExists {
		// Prompt user
		fmt.Printf("Branch '%s' does not exist. Create it? [y/N]: ", branch)
		reader := bufio.NewReader(os.Stdin)
		answer, _ := reader.ReadString('\n')
		answer = strings.TrimSpace(strings.ToLower(answer))

		if answer != "y" && answer != "yes" {
			fmt.Println("Aborted.")
			return nil
		}
	}

	// Create worktree
	fmt.Printf("Creating worktree at %s...\n", wtPath)
	if err := git.AddWorktree(repoRoot, wtPath, branch, !branchExists); err != nil {
		return err
	}
	fmt.Println("Worktree created.")

	// Sync files
	if len(cfg.Sync) > 0 {
		fmt.Println("Syncing files...")
		if err := sync.SyncAll(repoRoot, wtPath, cfg.Sync); err != nil {
			return fmt.Errorf("failed to sync files: %w", err)
		}
		fmt.Printf("Synced %d file(s).\n", len(cfg.Sync))
	}

	// Run post-install tasks
	if len(cfg.Tasks.PostInstall.Commands) > 0 {
		fmt.Println("Running post-install tasks...")
		isBackground := cfg.Tasks.PostInstall.Mode == "background"
		if err := runner.RunCommands(wtPath, cfg.Tasks.PostInstall.Commands, isBackground); err != nil {
			return fmt.Errorf("post-install failed: %w", err)
		}
		if isBackground {
			fmt.Println("Background tasks started.")
		} else {
			fmt.Println("Post-install completed.")
		}
	}

	fmt.Printf("\nWorktree ready: %s\n", wtPath)
	fmt.Printf("  cd %s\n", wtPath)

	return nil
}
```

**Step 3: Verify add command compiles**

Run: `go build -o wm .`
Expected: Binary compiles without errors

**Step 4: Commit**

```bash
git add cmd/add.go internal/runner/
git commit -m "feat: add wm add command with sync and bg tasks"
```

---

### Task 12: Implement `wm remove` Command

**Files:**
- Create: `cmd/remove.go`

**Step 1: Create remove command**

Create `cmd/remove.go`:
```go
package cmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/donghun/wm/internal/git"
	"github.com/spf13/cobra"
)

var (
	removeForce        bool
	removeDeleteBranch bool
)

var removeCmd = &cobra.Command{
	Use:     "remove <path>",
	Aliases: []string{"rm"},
	Short:   "Remove a worktree",
	Long:    "Remove a git worktree. Optionally delete the associated branch.",
	Args:    cobra.ExactArgs(1),
	RunE:    runRemove,
}

func init() {
	removeCmd.Flags().BoolVarP(&removeForce, "force", "f", false, "Force removal without confirmation")
	removeCmd.Flags().BoolVarP(&removeDeleteBranch, "branch", "b", false, "Also delete the branch")
	rootCmd.AddCommand(removeCmd)
}

func runRemove(cmd *cobra.Command, args []string) error {
	wtPath := args[0]

	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	repoRoot, err := git.GetRepoRoot(cwd)
	if err != nil {
		return err
	}

	// Find the worktree to get branch info
	worktrees, err := git.ListWorktrees(repoRoot)
	if err != nil {
		return err
	}

	var targetWT *git.Worktree
	for i, wt := range worktrees {
		if wt.Path == wtPath || strings.HasSuffix(wt.Path, "/"+wtPath) {
			targetWT = &worktrees[i]
			wtPath = wt.Path // Use full path
			break
		}
	}

	if targetWT == nil {
		return fmt.Errorf("worktree '%s' not found", wtPath)
	}

	// Prevent removing main worktree
	if targetWT.Path == repoRoot {
		return fmt.Errorf("cannot remove the main worktree")
	}

	// Confirmation prompt
	if !removeForce {
		fmt.Printf("Remove worktree at '%s'", wtPath)
		if removeDeleteBranch && targetWT.Branch != "" {
			fmt.Printf(" and branch '%s'", targetWT.Branch)
		}
		fmt.Print("? [y/N]: ")

		reader := bufio.NewReader(os.Stdin)
		answer, _ := reader.ReadString('\n')
		answer = strings.TrimSpace(strings.ToLower(answer))

		if answer != "y" && answer != "yes" {
			fmt.Println("Aborted.")
			return nil
		}
	}

	// Check if branch is used by another worktree
	if removeDeleteBranch && targetWT.Branch != "" {
		for _, wt := range worktrees {
			if wt.Path != wtPath && wt.Branch == targetWT.Branch {
				return fmt.Errorf("cannot delete branch '%s': used by worktree at '%s'", targetWT.Branch, wt.Path)
			}
		}
	}

	// Remove worktree
	fmt.Printf("Removing worktree...")
	if err := git.RemoveWorktree(repoRoot, wtPath, removeForce); err != nil {
		return err
	}
	fmt.Println(" done.")

	// Delete branch if requested
	if removeDeleteBranch && targetWT.Branch != "" {
		fmt.Printf("Deleting branch '%s'...", targetWT.Branch)
		if err := git.DeleteBranch(repoRoot, targetWT.Branch, false); err != nil {
			fmt.Printf(" failed: %v\n", err)
			fmt.Println("Tip: Use 'git branch -D' to force delete.")
		} else {
			fmt.Println(" done.")
		}
	}

	return nil
}
```

**Step 2: Verify remove command compiles**

Run: `go build -o wm .`
Expected: Binary compiles without errors

**Step 3: Commit**

```bash
git add cmd/remove.go
git commit -m "feat: add wm remove command with -b and -f flags"
```

---

## Phase 7: TUI Init Command

### Task 13: Add Bubble Tea Dependencies

**Files:**
- Modify: `go.mod`

**Step 1: Install Bubble Tea and Lip Gloss**

Run:
```bash
go get github.com/charmbracelet/bubbletea@latest
go get github.com/charmbracelet/lipgloss@latest
go get github.com/charmbracelet/bubbles@latest
```
Expected: Dependencies added to go.mod

**Step 2: Commit**

```bash
git add go.mod go.sum
git commit -m "chore: add bubble tea TUI dependencies"
```

---

### Task 14: Implement `wm init` TUI

**Files:**
- Create: `cmd/init.go`
- Create: `internal/tui/init.go`

**Step 1: Create TUI model**

Create `internal/tui/init.go`:
```go
package tui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/donghun/wm/internal/config"
	"github.com/donghun/wm/internal/detect"
)

var (
	focusedStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("205"))
	blurredStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
	titleStyle   = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("99"))
	helpStyle    = lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
)

type InitModel struct {
	step       int
	inputs     []textinput.Model
	focusIndex int
	syncFiles  []string
	detection  detect.DetectionResult
	repoName   string
	repoRoot   string
	done       bool
	result     *config.Config
}

func NewInitModel(repoRoot, repoName string, detection detect.DetectionResult) InitModel {
	m := InitModel{
		step:      0,
		inputs:    make([]textinput.Model, 2),
		detection: detection,
		repoName:  repoName,
		repoRoot:  repoRoot,
		syncFiles: []string{".env"},
	}

	// Base directory input
	var t textinput.Model
	t = textinput.New()
	t.Placeholder = "../wm_{repo}"
	t.SetValue("../wm_{repo}")
	t.Focus()
	t.CharLimit = 256
	t.Width = 40
	m.inputs[0] = t

	// Sync files input
	t = textinput.New()
	t.Placeholder = ".env, apps/*/.env"
	t.SetValue(".env")
	t.CharLimit = 512
	t.Width = 40
	m.inputs[1] = t

	return m
}

func (m InitModel) Init() tea.Cmd {
	return textinput.Blink
}

func (m InitModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc":
			return m, tea.Quit

		case "tab", "shift+tab", "up", "down":
			s := msg.String()
			if s == "up" || s == "shift+tab" {
				m.focusIndex--
			} else {
				m.focusIndex++
			}

			if m.focusIndex >= len(m.inputs) {
				m.focusIndex = 0
			} else if m.focusIndex < 0 {
				m.focusIndex = len(m.inputs) - 1
			}

			cmds := make([]tea.Cmd, len(m.inputs))
			for i := range m.inputs {
				if i == m.focusIndex {
					cmds[i] = m.inputs[i].Focus()
				} else {
					m.inputs[i].Blur()
				}
			}

			return m, tea.Batch(cmds...)

		case "enter":
			m.done = true
			m.result = m.buildConfig()
			return m, tea.Quit
		}
	}

	// Handle input updates
	cmd := m.updateInputs(msg)
	return m, cmd
}

func (m *InitModel) updateInputs(msg tea.Msg) tea.Cmd {
	cmds := make([]tea.Cmd, len(m.inputs))
	for i := range m.inputs {
		m.inputs[i], cmds[i] = m.inputs[i].Update(msg)
	}
	return tea.Batch(cmds...)
}

func (m InitModel) View() string {
	var b strings.Builder

	b.WriteString(titleStyle.Render("WM Init"))
	b.WriteString("\n\n")

	// Detection info
	if m.detection.PackageManager != "" {
		b.WriteString(fmt.Sprintf("Detected: %s", m.detection.PackageManager))
		if m.detection.IsMonorepo {
			b.WriteString(" (monorepo)")
		}
		b.WriteString("\n\n")
	}

	// Base directory
	b.WriteString("Worktree base directory:\n")
	b.WriteString(m.inputs[0].View())
	b.WriteString("\n\n")

	// Sync files
	b.WriteString("Files to sync (comma-separated):\n")
	b.WriteString(m.inputs[1].View())
	b.WriteString("\n\n")

	// Help
	b.WriteString(helpStyle.Render("tab: next field • enter: save • esc: cancel"))

	return b.String()
}

func (m InitModel) buildConfig() *config.Config {
	cfg := config.NewConfig()
	cfg.Worktree.BaseDir = m.inputs[0].Value()

	// Parse sync files
	syncStr := m.inputs[1].Value()
	if syncStr != "" {
		parts := strings.Split(syncStr, ",")
		cfg.Sync = make([]config.SyncItem, len(parts))
		for i, part := range parts {
			path := strings.TrimSpace(part)
			cfg.Sync[i] = config.SyncItem{
				Src:  path,
				Dst:  path,
				Mode: "copy",
				When: "always",
			}
		}
	}

	// Add detected install command
	if m.detection.InstallCommand != "" {
		cfg.Tasks.PostInstall = config.PostInstallConfig{
			Mode:     "background",
			Commands: []string{m.detection.InstallCommand},
		}
	}

	return cfg
}

func (m InitModel) Result() *config.Config {
	return m.result
}

func (m InitModel) Done() bool {
	return m.done
}

// RunInitTUI runs the init TUI and returns the config
func RunInitTUI(repoRoot, repoName string, detection detect.DetectionResult) (*config.Config, error) {
	model := NewInitModel(repoRoot, repoName, detection)
	p := tea.NewProgram(model)

	finalModel, err := p.Run()
	if err != nil {
		return nil, err
	}

	m := finalModel.(InitModel)
	if !m.Done() {
		return nil, fmt.Errorf("cancelled")
	}

	return m.Result(), nil
}
```

**Step 2: Create init command**

Create `cmd/init.go`:
```go
package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/donghun/wm/internal/config"
	"github.com/donghun/wm/internal/detect"
	"github.com/donghun/wm/internal/tui"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize WM configuration",
	Long:  "Create a .wm.yaml configuration file with interactive TUI.",
	RunE:  runInit,
}

func init() {
	rootCmd.AddCommand(initCmd)
}

func runInit(cmd *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current directory: %w", err)
	}

	// Check if already initialized
	configPath := filepath.Join(cwd, config.ConfigFileName)
	if _, err := os.Stat(configPath); err == nil {
		return fmt.Errorf("%s already exists. Delete it first to reinitialize", config.ConfigFileName)
	}

	repoName := filepath.Base(cwd)

	// Detect package manager
	detection := detect.Detect(cwd)

	// Run TUI
	cfg, err := tui.RunInitTUI(cwd, repoName, detection)
	if err != nil {
		return err
	}

	// Save config
	if err := config.SaveConfig(configPath, cfg); err != nil {
		return err
	}

	fmt.Printf("\nCreated %s\n", config.ConfigFileName)
	fmt.Println("\nNext steps:")
	fmt.Println("  wm add <branch>  # Create a worktree")
	fmt.Println("  wm list          # List worktrees")

	return nil
}
```

**Step 3: Verify init command compiles**

Run: `go build -o wm .`
Expected: Binary compiles without errors

**Step 4: Commit**

```bash
git add cmd/init.go internal/tui/
git commit -m "feat: add wm init command with TUI"
```

---

## Phase 8: Testing & Polish

### Task 15: Add Integration Tests

**Files:**
- Create: `tests/integration_test.go`

**Step 1: Create integration test**

Create `tests/integration_test.go`:
```go
package tests

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func setupTestRepo(t *testing.T) string {
	t.Helper()
	tmpDir := t.TempDir()

	cmds := [][]string{
		{"git", "init"},
		{"git", "config", "user.email", "test@test.com"},
		{"git", "config", "user.name", "Test"},
	}

	for _, args := range cmds {
		cmd := exec.Command(args[0], args[1:]...)
		cmd.Dir = tmpDir
		if out, err := cmd.CombinedOutput(); err != nil {
			t.Fatalf("setup command %v failed: %v\n%s", args, err, out)
		}
	}

	// Create initial commit
	readme := filepath.Join(tmpDir, "README.md")
	if err := os.WriteFile(readme, []byte("# Test"), 0644); err != nil {
		t.Fatal(err)
	}

	cmds = [][]string{
		{"git", "add", "."},
		{"git", "commit", "-m", "initial"},
	}

	for _, args := range cmds {
		cmd := exec.Command(args[0], args[1:]...)
		cmd.Dir = tmpDir
		if out, err := cmd.CombinedOutput(); err != nil {
			t.Fatalf("commit command %v failed: %v\n%s", args, err, out)
		}
	}

	return tmpDir
}

func buildWM(t *testing.T) string {
	t.Helper()
	tmpBin := filepath.Join(t.TempDir(), "wm")

	cmd := exec.Command("go", "build", "-o", tmpBin, "..")
	if out, err := cmd.CombinedOutput(); err != nil {
		t.Fatalf("build failed: %v\n%s", err, out)
	}

	return tmpBin
}

func TestE2E_ListEmpty(t *testing.T) {
	wmBin := buildWM(t)
	repoDir := setupTestRepo(t)

	cmd := exec.Command(wmBin, "list")
	cmd.Dir = repoDir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("wm list failed: %v\n%s", err, out)
	}

	if !strings.Contains(string(out), "PATH") {
		t.Errorf("expected table header, got: %s", out)
	}
}

func TestE2E_AddAndRemove(t *testing.T) {
	wmBin := buildWM(t)
	repoDir := setupTestRepo(t)

	// Create .wm.yaml
	configContent := `version: 1
worktree:
  base_dir: "../wm_test"
sync: []
`
	if err := os.WriteFile(filepath.Join(repoDir, ".wm.yaml"), []byte(configContent), 0644); err != nil {
		t.Fatal(err)
	}

	// Add worktree (auto-create branch)
	cmd := exec.Command(wmBin, "add", "feature-test")
	cmd.Dir = repoDir
	cmd.Stdin = strings.NewReader("y\n") // Answer yes to create branch
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("wm add failed: %v\n%s", err, out)
	}

	if !strings.Contains(string(out), "Worktree ready") {
		t.Errorf("expected success message, got: %s", out)
	}

	// Verify worktree exists
	wtPath := filepath.Join(repoDir, "..", "wm_test", "feature-test")
	if _, err := os.Stat(wtPath); os.IsNotExist(err) {
		t.Error("worktree directory was not created")
	}

	// List should show 2 worktrees
	cmd = exec.Command(wmBin, "list")
	cmd.Dir = repoDir
	out, _ = cmd.CombinedOutput()
	if !strings.Contains(string(out), "feature-test") {
		t.Errorf("expected feature-test in list, got: %s", out)
	}

	// Remove worktree
	cmd = exec.Command(wmBin, "remove", "-f", wtPath)
	cmd.Dir = repoDir
	out, err = cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("wm remove failed: %v\n%s", err, out)
	}

	// List should show 1 worktree
	cmd = exec.Command(wmBin, "list")
	cmd.Dir = repoDir
	out, _ = cmd.CombinedOutput()
	if strings.Contains(string(out), "feature-test") {
		t.Errorf("feature-test should be removed, got: %s", out)
	}
}

func TestE2E_SyncFiles(t *testing.T) {
	wmBin := buildWM(t)
	repoDir := setupTestRepo(t)

	// Create .env in repo
	envContent := "SECRET=test123"
	if err := os.WriteFile(filepath.Join(repoDir, ".env"), []byte(envContent), 0644); err != nil {
		t.Fatal(err)
	}

	// Create .wm.yaml with sync
	configContent := `version: 1
worktree:
  base_dir: "../wm_sync_test"
sync:
  - ".env"
`
	if err := os.WriteFile(filepath.Join(repoDir, ".wm.yaml"), []byte(configContent), 0644); err != nil {
		t.Fatal(err)
	}

	// Commit .env so we can create worktree
	cmd := exec.Command("git", "add", ".env", ".wm.yaml")
	cmd.Dir = repoDir
	cmd.Run()
	cmd = exec.Command("git", "commit", "-m", "add env")
	cmd.Dir = repoDir
	cmd.Run()

	// Add worktree
	cmd = exec.Command(wmBin, "add", "sync-test")
	cmd.Dir = repoDir
	cmd.Stdin = strings.NewReader("y\n")
	if out, err := cmd.CombinedOutput(); err != nil {
		t.Fatalf("wm add failed: %v\n%s", err, out)
	}

	// Verify .env was synced
	wtPath := filepath.Join(repoDir, "..", "wm_sync_test", "sync-test")
	syncedEnv := filepath.Join(wtPath, ".env")
	content, err := os.ReadFile(syncedEnv)
	if err != nil {
		t.Fatalf("failed to read synced .env: %v", err)
	}

	if string(content) != envContent {
		t.Errorf("expected '%s', got '%s'", envContent, content)
	}
}

func TestE2E_RemoveWithBranch(t *testing.T) {
	wmBin := buildWM(t)
	repoDir := setupTestRepo(t)

	// Create config
	configContent := `version: 1
worktree:
  base_dir: "../wm_branch_test"
`
	if err := os.WriteFile(filepath.Join(repoDir, ".wm.yaml"), []byte(configContent), 0644); err != nil {
		t.Fatal(err)
	}

	// Add worktree
	cmd := exec.Command(wmBin, "add", "branch-to-delete")
	cmd.Dir = repoDir
	cmd.Stdin = strings.NewReader("y\n")
	cmd.Run()

	wtPath := filepath.Join(repoDir, "..", "wm_branch_test", "branch-to-delete")

	// Remove with -b flag
	cmd = exec.Command(wmBin, "remove", "-f", "-b", wtPath)
	cmd.Dir = repoDir
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("wm remove -b failed: %v\n%s", err, out)
	}

	// Verify branch is deleted
	cmd = exec.Command("git", "branch", "--list", "branch-to-delete")
	cmd.Dir = repoDir
	out, _ = cmd.CombinedOutput()
	if strings.Contains(string(out), "branch-to-delete") {
		t.Error("branch should have been deleted")
	}
}

func TestE2E_Version(t *testing.T) {
	wmBin := buildWM(t)

	cmd := exec.Command(wmBin, "version")
	out, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("wm version failed: %v\n%s", err, out)
	}

	if !strings.Contains(string(out), "wm") {
		t.Errorf("expected version info, got: %s", out)
	}
}
```

**Step 2: Run integration tests**

Run: `go test ./tests/... -v`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add tests/
git commit -m "test: add integration tests for E2E scenarios"
```

---

### Task 16: Update README

**Files:**
- Modify: `README.md` (create if not exists)

**Step 1: Create README**

Create `README.md`:
```markdown
# WM - Git Worktree Manager

A CLI tool that makes git worktree easier to use with file sync and background tasks.

## Installation

```bash
go install github.com/donghun/wm@latest
```

## Quick Start

```bash
# Initialize in your project
wm init

# Create a worktree for a feature branch
wm add feature-login

# List all worktrees
wm list

# Remove a worktree
wm remove ../wm_myrepo/feature-login

# Remove worktree and delete branch
wm remove -b ../wm_myrepo/feature-login
```

## Configuration

WM uses a `.wm.yaml` file in your project root:

```yaml
version: 1

worktree:
  base_dir: "../wm_{repo}"  # {repo} is replaced with repo name

sync:
  - ".env"                              # Copy .env to worktree
  - "apps/*/.env"                       # Glob patterns supported
  - src: ".env.example"
    dst: ".env"
    mode: copy                          # or "symlink"
    when: missing                       # or "always"

tasks:
  post_install:
    mode: background                    # Run async
    commands:
      - "pnpm install"
```

## Commands

### `wm init`

Interactive setup to create `.wm.yaml`.

### `wm add <branch>`

Create a new worktree. Options:
- `--path, -p`: Custom worktree path

### `wm list`

List all worktrees in table format.

### `wm remove <path>`

Remove a worktree. Options:
- `-f, --force`: Skip confirmation
- `-b, --branch`: Also delete the branch

## License

MIT
```

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add README with usage examples"
```

---

### Task 17: Add Build Script with Version Info

**Files:**
- Create: `Makefile`

**Step 1: Create Makefile**

Create `Makefile`:
```makefile
VERSION ?= $(shell git describe --tags --always --dirty 2>/dev/null || echo "dev")
COMMIT ?= $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")
DATE ?= $(shell date -u +"%Y-%m-%dT%H:%M:%SZ")

LDFLAGS = -X github.com/donghun/wm/internal/version.Version=$(VERSION) \
          -X github.com/donghun/wm/internal/version.GitCommit=$(COMMIT) \
          -X github.com/donghun/wm/internal/version.BuildDate=$(DATE)

.PHONY: build test clean install

build:
	go build -ldflags "$(LDFLAGS)" -o wm .

test:
	go test ./... -v

clean:
	rm -f wm

install:
	go install -ldflags "$(LDFLAGS)" .

# Run all tests including integration
test-all:
	go test ./... -v -count=1
```

**Step 2: Test build with version**

Run: `make build && ./wm version`
Expected: Shows version with commit hash and build date

**Step 3: Commit**

```bash
git add Makefile
git commit -m "build: add Makefile with version injection"
```

---

## Summary

This plan implements WM 2.0 CLI with:

1. **Phase 1**: Project skeleton with Cobra CLI
2. **Phase 2**: Config types and YAML loader
3. **Phase 3**: Git worktree wrapper
4. **Phase 4**: File sync (copy/symlink)
5. **Phase 5**: Monorepo detection
6. **Phase 6**: CLI commands (list, add, remove)
7. **Phase 7**: TUI init command
8. **Phase 8**: Integration tests and documentation

Total: 17 tasks following TDD (test → fail → implement → pass → commit)
